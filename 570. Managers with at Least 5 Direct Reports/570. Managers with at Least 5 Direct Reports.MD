LeetCode 570: Managers with at Least 5 Direct Reports
=====================================================

==============================

Problem Description
--------------------

* * * * *

Write an SQL query to find the names of managers who have at least five direct reports.

Return the result table in any order.

* * * * *

Table Schema
--------------------


### `Employee`

| Column Name | Type | Description |
| --- | --- | --- |
| `id` | int | The primary key of the table. |
| `name` | varchar | The name of the employee. |
| `department` | varchar | The department of the employee. |
| `managerId` | int | The ID of the employee's manager (foreign key to id). |

* * * * *

Example Input
--------------------


### `Employee` Table:

| id | name | department | managerId |
| --- | --- | --- | --- |
| 101 | John | A | null |
| 102 | Dan | A | 101 |
| 103 | James | A | 101 |
| 104 | Amy | A | 101 |
| 105 | Anne | A | 101 |
| 106 | Ron | B | 101 |
| 107 | Tom | C | 103 |
| 108 | Bob | C | 103 |
| 109 | Alice | C | 103 |
| 110 | Jack | C | 103 |
| 111 | Sam | C | 103 |

* * * * *

Expected Output
--------------------

| name |
| --- |
| John |
| James |

Explanation:

-   John (id: 101) has 5 direct reports: Dan, James, Amy, Anne, Ron

-   James (id: 103) has 5 direct reports: Tom, Bob, Alice, Jack, Sam

* * * * *

SQL Solution
--------------------

```sql

SELECT m.name
FROM employee AS e
INNER JOIN employee AS m
ON e.managerId = m.id
GROUP BY e.managerId
HAVING count(e.id) >= 5;
```
* * * * *

Query Explanation
--------------------


### Step 1: Self-Join to Connect Employees with Their Managers

```sql

FROM employee AS e
INNER JOIN employee AS m
ON e.managerId = m.id
```
-   Self-Join: We join the Employee table with itself

-   Aliases:

    -   `e` represents employees (the direct reports)

    -   `m` represents managers

-   Join Condition: `e.managerId = m.id` connects each employee to their manager

-   This creates pairs where we can see which employees report to which managers

### Step 2: Group by Manager to Count Direct Reports

```sql

GROUP BY e.managerId
```
-   We group by the manager's ID (`e.managerId`)

-   This aggregates all employees that report to the same manager into one group

-   Each group represents all direct reports for a particular manager

### Step 3: Filter Managers with At Least 5 Direct Reports

```sql

HAVING count(e.id) >= 5
```
-   HAVING clause: Filters the grouped results after aggregation

-   COUNT([e.id](https://e.id/)): Counts the number of employees in each manager's group

-  >= 5: Only keeps managers who have 5 or more direct reports

### Step 4: Select Manager Names

```sql

SELECT m.name
```
-   We select the manager's name from the `m` (manager) alias

-   Since we grouped by `e.managerId` (which is the same as `m.id`), we can safely select `m.name`

### Alternative Solutions:

Using Subquery:

```sql

SELECT name
FROM Employee
WHERE id IN (
    SELECT managerId
    FROM Employee
    GROUP BY managerId
    HAVING COUNT(*) >= 5
);
```
Using Window Function:

```sql

SELECT DISTINCT m.name
FROM (
    SELECT managerId,
           COUNT(*) OVER (PARTITION BY managerId) as report_count
    FROM Employee
    WHERE managerId IS NOT NULL
) AS counts
JOIN Employee m ON counts.managerId = m.id
WHERE counts.report_count >= 5;
```
### Key Points:

1.  Self-Join: Essential for connecting employees to their managers within the same table

2.  GROUP BY managerId: Groups all direct reports under their respective managers

3.  HAVING vs WHERE:

    -   WHERE filters rows before aggregation

    -   HAVING filters groups after aggregation

4.  NULL Handling: The query automatically excludes employees with NULL managerId (top-level executives with no managers)

Why This Works: The self-join creates the manager-employee relationships, the grouping counts how many employees report to each manager, and the HAVING clause filters for managers who meet the minimum direct report requirement.