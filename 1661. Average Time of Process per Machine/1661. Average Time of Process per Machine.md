LeetCode 1661: Average Time of Process per Machine
==================================================

==============================

Problem Description
-----------------

* * * * *

There is a factory website that has several machines each running the same number of processes. Write an SQL query to find the average time each machine takes to complete a process.

The time to complete a process is the difference between the 'end' timestamp and the 'start' timestamp for each process. Note that each process has exactly one 'start' and one 'end' timestamp.

Return the result table in any order.

* * * * *

Table Schema
-----------------

### `Activity`

| Column Name | Type | Description |
| --- | --- | --- |
| `machine_id` | int | The ID of the machine. |
| `process_id` | int | The ID of the process running on the machine. |
| `activity_type` | enum | The type of activity ('start', 'end'). |
| `timestamp` | float | The timestamp of the activity. |

* * * * *

Example Input
-----------------

### `Activity` Table:

| machine_id | process_id | activity_type | timestamp |
| --- | --- | --- | --- |
| 0 | 0 | start | 0.712 |
| 0 | 0 | end | 1.520 |
| 0 | 1 | start | 3.140 |
| 0 | 1 | end | 4.120 |
| 1 | 0 | start | 0.550 |
| 1 | 0 | end | 1.550 |
| 1 | 1 | start | 0.430 |
| 1 | 1 | end | 1.420 |
| 2 | 0 | start | 4.100 |
| 2 | 0 | end | 4.512 |
| 2 | 1 | start | 2.500 |
| 2 | 1 | end | 5.000 |

* * * * *

Expected Output
-----------------


| machine_id | processing_time |
| --- | --- |
| 0 | 0.894 |
| 1 | 0.995 |
| 2 | 1.456 |

Explanation:

-   Machine 0: ((1.520 - 0.712) + (4.120 - 3.140)) / 2 = (0.808 + 0.980) / 2 = 0.894

-   Machine 1: ((1.550 - 0.550) + (1.420 - 0.430)) / 2 = (1.000 + 0.990) / 2 = 0.995

-   Machine 2: ((4.512 - 4.100) + (5.000 - 2.500)) / 2 = (0.412 + 2.500) / 2 = 1.456

* * * * *

SQL Solution
-----------------

```sql

SELECT machine_id,
ROUND(
  SUM(CASE WHEN activity_type = 'start' THEN timestamp * -1
  ELSE timestamp END) / COUNT(DISTINCT process_id), 3
) AS processing_time
FROM Activity
GROUP BY machine_id;
```
* * * * *

Query Explanation
-----------------


### Step 1: Understanding the Data Structure

Each process has exactly two rows in the Activity table:

-   One with `activity_type = 'start'` and a timestamp

-   One with `activity_type = 'end'` and a timestamp

### Step 2: The CASE Statement Logic

```sql

CASE WHEN activity_type = 'start' THEN timestamp * -1
     ELSE timestamp END
```

This clever CASE statement:

-   Multiplies 'start' timestamps by -1 (making them negative)

-   Keeps 'end' timestamps as positive

When we SUM these values for each process, we get:\
`(end_timestamp) + (-start_timestamp) = end_timestamp - start_timestamp`

This gives us the processing time for each individual process.

### Step 3: Aggregation and Calculation

```sql

SUM(CASE WHEN activity_type = 'start' THEN timestamp * -1
        ELSE timestamp END) / COUNT(DISTINCT process_id)
```
-   SUM(): Adds up all the (end_timestamp - start_timestamp) differences for all processes on a machine

-   COUNT(DISTINCT process_id): Counts the number of unique processes per machine

-   Division: Gives us the average processing time per machine

### Step 4: Rounding and Grouping

```sql

ROUND(..., 3)
```
Rounds the result to 3 decimal places as required.

```sql

GROUP BY machine_id
```
Groups the results by machine so we get one row per machine with its average processing time.

### Alternative Solution (Using Self-Join):

```sql

SELECT
    a.machine_id,
    ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time
FROM Activity a
JOIN Activity b ON
    a.machine_id = b.machine_id
    AND a.process_id = b.process_id
    AND a.activity_type = 'start'
    AND b.activity_type = 'end'
GROUP BY a.machine_id;
```
Key Insight: The original solution is elegant because it processes all rows in a single pass without needing joins, making it very efficient. The CASE statement approach cleverly uses arithmetic to calculate the time differences directly in the aggregation.